$schema: properties.schema.json

OrchestrationPort:
  key: compose.reload.orchestration.port
  type: int
  target: [ build, devtools, application ]
  documentation: |
    Current 'Orchestration Server' port. This property is used by components that shall connect to the 
    'orchestration' (e.g. recompiler, devtools, ...)

PidFile:
  key: compose.reload.pidFile
  type: file
  target: [ application ]
  documentation: |
    Path to the current applications pidfile

ArgFile:
  key: compose.reload.argfile
  type: file
  target: [ application, devtools, build]
  documentation: |
    The java 'argfile' (see: https://docs.oracle.com/en/java/javase/21/docs/specs/man/java.html#java-command-line-argument-files)
    containing all arguments of the current run

IsHeadless:
  key: compose.reload.headless
  type: boolean
  default: "false"
  target: [ application, build ]
  documentation: |
    Indicating whether or not the application is supposed to run in headless mode

IsHotReloadBuild:
  key: compose.reload.isHotReloadBuild
  type: boolean
  default: "false"
  target: [ build ]
  documentation: |
    Available in the build (e.g. Gradle) to indicate whether or not the current build is intended
    to recompile classes for a hot reload build. Typically, this property is used to disable tasks
    which are not required to produce classes and improve build speed.

HotClasspath:
  key: compose.reload.hotApplicationClasspath
  type: string
  target: [ application ]
  documentation: |
    The classpath known to be hot. This property is optional

VirtualMethodResolveEnabled:
  key: compose.reload.virtualMethodResolveEnabled
  type: boolean
  default: "true"
  target: [ application, build ]
  documentation: |
    true: Enable dependency analysis for virtual calls:
    e.g. Interfaces and their corresponding implementations will be tracked 

DirtyResolveDepthLimit:
  key: compose.reload.dirtyResolveDepthLimit
  type: int
  default: "5"
  target: [ application, build ]
  documentation: |
    If a given scope is marked as dirty, then Hot Reload will follow the dependency graph between fields/methods
    and further marks scopes as dirty. This property limits how deep this graph can be traversed.

BuildSystem:
  key: compose.reload.buildSystem
  type: enum
  enumClass: org.jetbrains.compose.reload.core.BuildSystem
  target: [ application ]
  documentation: |
    Indicating the application which build system is supposed to be used for recompiling.
    See further build-system specific (Gradle, Amper, ...) properties.

GradleJavaHome:
  key: org.gradle.java.home
  type: file
  target: [ application ]
  documentation: |
    The 'java home' used to run Gradle. The recompiler will pick the same java to launch 
    the recompiler in order to avoid cache misses or other issues.

GradleBuildRoot:
  key: gradle.build.root
  type: file
  target: [ application ]
  documentation: |
    The root path to the current Gradle project

GradleBuildProject:
  key: gradle.build.project
  type: string
  target: [ application ]
  documentation: |
    The gradle 'path' to the 'project' which is currently executed and needs recompiling.
    e.g. ':app:' or ':' or ':someModule:composeApp'

GradleBuildTask:
  key: gradle.build.task
  type: string
  target: [ application ]
  documentation: |
    The name of the task which is supposed to be recompiled for hot reload. 
    This is typically the name of a 'ComposeReloadHotClasspathTask' task. 

GradleBuildContinuous:
  key: compose.reload.build.continuous
  type: boolean
  default: "true"
  target: [ application, build ]
  documentation: |
    - true: Compose Hot Reload will start a recompiler Gradle Daemon, which will continuously rebuilt/reload the project
    by watching all  inputs to the build
    - false: The user is expected to rebuild/reload manually by launching a task (or using tooling)

AmperBuildRoot:
  key: amper.build.root
  type: string
  target: [ application ]

AmperBuildTask:
  key: amper.build.task
  type: string
  target: [ application ]

DevToolsEnabled:
  key: compose.reload.devToolsEnabled
  type: boolean
  default: "true"
  target: [ application, build ]
  documentation: |
    Flag to disable the 'devtools' application entirely

DevToolsClasspath:
  key: compose.reload.devToolsClasspath
  type: files
  target: [ application ]
  documentation: |
    The classpath notation of the devTools application. 
    Hot Reload will start DevTools in a different process and therefore needs the classpath

DevToolsTransparencyEnabled:
  key: compose.reload.devToolsTransparencyEnabled
  type: boolean
  default: "(Os.currentOrNull() != Os.Linux).toString()"
  defaultIsExpression: true
  target: [ application, build, devtools ]
  documentation: |
    Some platforms might not be able to render transparency correctly (e.g. some linux environments).
    This property will allow such platforms to disable/enable transparency

IntelliJDebuggerDispatchPort:
  key: compose.reload.idea.debugger.dispatch.port
  type: int
  target: [ application ]
  documentation: |
    Note: Expected as an environment variable, as this is expected to be transitively available
    to all child processes.\n
    Currently, launching applications with hot reload might be done through a couple of
    intermediate processes. For example, launching a test will go through a chain like
    ```
    intellij --launches--> Gradle --launches--> JVM(Junit) --launches--> Gradle
    --launches--> JVM (Application)
    ```
    When a run configuration is started in 'debug mode' intellij will set the system property
    'idea.debugger.dispatch.port'. This will indicate that a server is listening at this port, which can
    be used to provision debugging servers.
    This debug port will then be made available as an environment variable using this key.
    Launching the final application will respect this port, if present and provision a debugging session.
    This will allow a test to be deeply debuggable by just pressing 'Debug'

JetBrainsRuntimeBinary:
  key: compose.reload.jbr.binary
  type: file
  target: [ build ]
  documentation: |
    The path to the 'JetBrainsRuntime' which shall be used when launching the app. 
    Note: This is a build-only property!

AutoRuntimeDependenciesEnabled:
  key: compose.reload.autoRuntimeDependenciesEnabled
  type: boolean
  default: "true"
  target: [ build ]
  documentation: |
    Whether or not the hot-reload-runtime will be added as a compile dependency automatically when running a build.

IdeaComposeHotReload:
  key: idea.compose.hot-reload
  type: boolean
  target: [ build ]
  default: "false"
  documentation: |
    Set by IntelliJ to signal the Gradle Plugin that IDE tooling is available.
    Setting this variable will relax the Gradle Plugin to not touch existing run tasks as we expect
    the IDE to provide a convenient way of launching in hot-reload mode.
